<h1>ipaddr.js â€” an IPv6 and IPv4 address manipulation library <a href="https://travis-ci.org/whitequark/ipaddr.js"><img src="https://travis-ci.org/whitequark/ipaddr.js.svg" alt="Build Status"></a></h1><p>ipaddr.js is a small (1.9K minified and gzipped) library for manipulating
IP addresses in JavaScript environments. It runs on both CommonJS runtimes
(e.g. <a href="http://nodejs.org">nodejs</a>) and in a web browser.</p>
<p>ipaddr.js allows you to verify and parse string representation of an IP
address, match it against a CIDR range or range list, determine if it falls
into some reserved ranges (examples include loopback and private ranges),
and convert between IPv4 and IPv4-mapped IPv6 addresses.</p>
<h2>Installation</h2><p><code>npm install ipaddr.js</code></p>
<h2>API</h2><p>ipaddr.js defines one object in the global scope: <code>ipaddr</code>. In CommonJS,
it is exported from the module:</p>
<pre><code class="language-js">var ipaddr = require(&#39;ipaddr.js&#39;);
</code></pre>
<p>The API consists of several global methods and two classes: ipaddr.IPv6 and ipaddr.IPv4.</p>
<h3>Global methods</h3><p>There are three global methods defined: <code>ipaddr.isValid</code>, <code>ipaddr.parse</code> and
<code>ipaddr.process</code>. All of them receive a string as a single parameter.</p>
<p>The <code>ipaddr.isValid</code> method returns <code>true</code> if the address is a valid IPv4 or
IPv6 address, and <code>false</code> otherwise. It does not throw any exceptions.</p>
<p>The <code>ipaddr.parse</code> method returns an object representing the IP address,
or throws an <code>Error</code> if the passed string is not a valid representation of an
IP address.</p>
<p>The <code>ipaddr.process</code> method works just like the <code>ipaddr.parse</code> one, but it
automatically converts IPv4-mapped IPv6 addresses to their IPv4 couterparts
before returning. It is useful when you have a Node.js instance listening
on an IPv6 socket, and the <code>net.ivp6.bindv6only</code> sysctl parameter (or its
equivalent on non-Linux OS) is set to 0. In this case, you can accept IPv4
connections on your IPv6-only socket, but the remote address will be mangled.
Use <code>ipaddr.process</code> method to automatically demangle it.</p>
<h3>Object representation</h3><p>Parsing methods return an object which descends from <code>ipaddr.IPv6</code> or
<code>ipaddr.IPv4</code>. These objects share some properties, but most of them differ.</p>
<h4>Shared properties</h4><p>One can determine the type of address by calling <code>addr.kind()</code>. It will return
either <code>&quot;ipv6&quot;</code> or <code>&quot;ipv4&quot;</code>.</p>
<p>An address can be converted back to its string representation with <code>addr.toString()</code>.
Note that this method:</p>
<ul>
<li>does not return the original string used to create the object (in fact, there is
no way of getting that string)</li>
<li>returns a compact representation (when it is applicable)</li>
</ul>
<p>A <code>match(range, bits)</code> method can be used to check if the address falls into a
certain CIDR range.
Note that an address can be (obviously) matched only against an address of the same type.</p>
<p>For example:</p>
<pre><code class="language-js">var addr = ipaddr.parse(&quot;2001:db8:1234::1&quot;);
var range = ipaddr.parse(&quot;2001:db8::&quot;);

addr.match(range, 32); // =&gt; true
</code></pre>
<p>Alternatively, <code>match</code> can also be called as <code>match([range, bits])</code>. In this way,
it can be used together with the <code>parseCIDR(string)</code> method, which parses an IP
address together with a CIDR range.</p>
<p>For example:</p>
<pre><code class="language-js">var addr = ipaddr.parse(&quot;2001:db8:1234::1&quot;);

addr.match(ipaddr.parseCIDR(&quot;2001:db8::/32&quot;)); // =&gt; true
</code></pre>
<p>A <code>range()</code> method returns one of predefined names for several special ranges defined
by IP protocols. The exact names (and their respective CIDR ranges) can be looked up
in the source: <a href="https://github.com/whitequark/ipaddr.js/blob/master/src/ipaddr.coffee#L186">IPv6 ranges</a> and <a href="https://github.com/whitequark/ipaddr.js/blob/master/src/ipaddr.coffee#L71">IPv4 ranges</a>. Some common ones include <code>&quot;unicast&quot;</code>
(the default one) and <code>&quot;reserved&quot;</code>.</p>
<p>You can match against your own range list by using
<code>ipaddr.subnetMatch(address, rangeList, defaultName)</code> method. It can work with both
IPv6 and IPv4 addresses, and accepts a name-to-subnet map as the range list. For example:</p>
<pre><code class="language-js">var rangeList = {
  documentationOnly: [ ipaddr.parse(&#39;2001:db8::&#39;), 32 ],
  tunnelProviders: [
    [ ipaddr.parse(&#39;2001:470::&#39;), 32 ], // he.net
    [ ipaddr.parse(&#39;2001:5c0::&#39;), 32 ]  // freenet6
  ]
};
ipaddr.subnetMatch(ipaddr.parse(&#39;2001:470:8:66::1&#39;), rangeList, &#39;unknown&#39;); // =&gt; &quot;he.net&quot;
</code></pre>
<p>The addresses can be converted to their byte representation with <code>toByteArray()</code>.
(Actually, JavaScript mostly does not know about byte buffers. They are emulated with
arrays of numbers, each in range of 0..255.)</p>
<pre><code class="language-js">var bytes = ipaddr.parse(&#39;2a00:1450:8007::68&#39;).toByteArray(); // ipv6.google.com
bytes // =&gt; [42, 0x00, 0x14, 0x50, 0x80, 0x07, 0x00, &lt;zeroes...&gt;, 0x00, 0x68 ]
</code></pre>
<p>The <code>ipaddr.IPv4</code> and <code>ipaddr.IPv6</code> objects have some methods defined, too. All of them
have the same interface for both protocols, and are similar to global methods.</p>
<p><code>ipaddr.IPvX.isValid(string)</code> can be used to check if the string is a valid address
for particular protocol, and <code>ipaddr.IPvX.parse(string)</code> is the error-throwing parser.</p>
<h4>IPv6 properties</h4><p>Sometimes you will want to convert IPv6 not to a compact string representation (with
the <code>::</code> substitution); the <code>toNormalizedString()</code> method will return an address where
all zeroes are explicit.</p>
<p>For example:</p>
<pre><code class="language-js">var addr = ipaddr.parse(&quot;2001:0db8::0001&quot;);
addr.toString(); // =&gt; &quot;2001:db8::1&quot;
addr.toNormalizedString(); // =&gt; &quot;2001:db8:0:0:0:0:0:1&quot;
</code></pre>
<p>The <code>isIPv4MappedAddress()</code> method will return <code>true</code> if this address is an IPv4-mapped
one, and <code>toIPv4Address()</code> will return an IPv4 object address.</p>
<p>To access the underlying binary representation of the address, use <code>addr.parts</code>.</p>
<pre><code class="language-js">var addr = ipaddr.parse(&quot;2001:db8:10::1234:DEAD&quot;);
addr.parts // =&gt; [0x2001, 0xdb8, 0x10, 0, 0, 0, 0x1234, 0xdead]
</code></pre>
<h4>IPv4 properties</h4><p><code>toIPv4MappedAddress()</code> will return a corresponding IPv4-mapped IPv6 address.</p>
<p>To access the underlying representation of the address, use <code>addr.octets</code>.</p>
<pre><code class="language-js">var addr = ipaddr.parse(&quot;192.168.1.1&quot;);
addr.octets // =&gt; [192, 168, 1, 1]
</code></pre>
